import json

Location = tuple[tuple[float, float, float], str | None]


def build_graph(
    cells: list[any],
) -> tuple[list[Location], dict[tuple[Location, Location], float]]:
    locations: set[Location] = set()
    distances: dict[tuple[Location, Location], float] = {}

    for cell in cells:
        for ref in cell["references"]:
            if "destination" in ref:
                source_location = (
                    tuple(ref["translation"]),
                    (
                        cell["name"]
                        if cell["name"] and "IS_INTERIOR" in cell["data"]["flags"]
                        else None
                    ),
                )
                target_location = (
                    tuple(ref["destination"]["translation"]),
                    ref["destination"]["cell"] if ref["destination"]["cell"] else None,
                )
                distances[(source_location, target_location)] = 0.0
                locations.add(source_location)
                locations.add(target_location)
    return list(locations), distances


def emit_cell(cell: str | None) -> str:
    return f'"{cell}"' if cell else "nil"


with open("./Morrowind.esm.json") as f:
    raw_graph = json.load(f)

cells = [g for g in raw_graph if g["type"] == "Cell"]

vertices, edges = build_graph(cells)

with open("./src/scripts/markers/graph.tl", "w") as f:
    f.write("-- Automatically generated by dump_graph.py, do not edit --\n\n")
    f.write("local util = require('openmw.util')\n\n")
    f.write("local CellCoords = require('scripts.markers.types').CellCoords\n")
    f.write("local RoutingGraph = require('scripts.markers.types').RoutingGraph\n")

    f.write("global VERTICES: {CellCoords} = {")
    for v_pos, v_cell in vertices:
        f.write(
            f"\n    {{coords=util.vector3({v_pos[0]},{v_pos[1]},{v_pos[2]}),cellId={emit_cell(v_cell)}}},"
        )
    f.write("\n};\n\n")

    f.write("global EDGES: {{CellCoords, CellCoords}:number} = {}\n")
    for (src, dest), cost in edges.items():
        ix_src = vertices.index(src)
        ix_dest = vertices.index(dest)
        f.write(
            f"EDGES[{{ VERTICES[{ix_src + 1}], VERTICES[{ix_dest + 1}] }}] = {cost}\n"
        )

    f.write("\nglobal GRAPH: RoutingGraph = {vertices = VERTICES, edges = EDGES}\n")
    f.write("return {graph = GRAPH}\n")
